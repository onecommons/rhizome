<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rdf:RDF [
     <!ENTITY rdf  "http://www.w3.org/1999/02/22-rdf-syntax-ns#" >
     <!ENTITY rdfs "http://www.w3.org/2000/01/rdf-schema#" >
     <!ENTITY xsd  "http://www.w3.org/2001/XMLSchema#" >
     <!ENTITY owl  "http://www.w3.org/2002/07/owl#" >
     <!ENTITY archive "http://www.souzis.com/adam/archive#">
   ]>

<rdf:RDF
  xmlns="&archive;"
  xmlns:owl ="&owl;"
  xml:base="http://www.souzis.com/adam/archive"
  xmlns:rdf ="&rdf;"
  xmlns:rdfs="&rdfs;"  
>

<owl:Ontology rdf:about="" xmlns:dc="http://purl.org/dc/elements/1.1/" >
  <owl:versionInfo>April 18. 2003, v0.1</owl:versionInfo>
  <dc:title>scalable content ontology</dc:title>
  <dc:creator>Adam Souzis, do.org</dc:creator>
  <dc:subject>ontology for representing content and collections of content</dc:subject>
  <dc:description>By a scalable ontology we mean one that provides more precise representation of content enabling widely disparate sources, system and authorities to annotate and reference each other. Ontologies and generally don't have a way of expressing what a content URL denotes -- they just accept the naive assumation that an URI denotes the same thing across time and space. Furthermore, current content management systems (using this term broadly) are closed systems where they control their URI space and can make assumptions about it. (aside, so we see hacks like blogs' duri-urls)    
  </dc:description>
  <dc:date>2003-04-10</dc:date>
  <dc:language>en</dc:language>
  <dc:identifier>http://www.souzis.com/adam/archive</dc:identifier>
</owl:Ontology>

<owl:Class rdf:ID="ContentRep" />   

<owl:Class rdf:ID="NamedContent" >   
<rdfs:subClassOf about="#ContentRep" />  
</owl:Class>

<!-- this base class applies to an resource that denotes content (hmm, define content) and is appropriate to be the subject of metadata about that content.
We define a set of subclasses that are progressively more specific about the exact content the resource denotes.
NamedContent: a general identifier of content, based on some or any intension -- the specific content can vary depending on the context, such as time and place
ContentLocation: is your everyday, in the wild URL that denotes a file at given location 
ContentSource: a resource similar to a ContentLocation, but specifies addition properties to remove any ambiguity about the location (fixing the place)
ContentInstance: ContentSource fixed in the time and specifies any transformation that might have applies 
Contents: a resource that denotes a fixed set of bytes. Because we can use a secure digest as the resource URI anyone can independently come up with its name

Assertions about content (metadata) can applied to any of these subclasses based on the level knowledge about the content: 
when NamedContent is the subject it asserts invariants that hold as long as content is appropriately given that name
when Content assertions about a specific representation 
Assertions about ContentInstances, ContentSources and ContentLocations may introduce ambiguity but appropriate when that is the only information available

Summary of relations:
folder <-> file -> content <-> instance -> csource -> clocation
--> 
<owl:ObjectProperty rdf:about="#has-expression" >  
<rdfs:domain rdf:resource="#NamedContent" />
<rdfs:range rdf:resource="#ContentRep" />
</owl:ObjectProperty>  

<owl:Class rdf:ID="Contents" >
  <rdfs:subClassOf about="#ContentRep" />  
<!-- represents a particular ordered set of bytes. external constraint: resource id should be urn:md5: or urn:sha: -->
  <rdfs:subClassOf >  
  <owl:intersectionOf rdf:parseType="Collection">
      <owl:Restriction> <!-- require a sha1-digest -->
          <owl:onProperty rdf:resource="#sha1-digest"/>
          <owl:cardinality rdf:datatype="&xsd;nonNegativeInteger">1</owl:cardinality>
      </owl:Restriction>
  </owl:intersectionOf>
  </rdfs:subClassOf>    
</owl:Class>

<owl:DatatypeProperty rdf:about="#hasContent">  
  <rdfs:domain rdf:resource="#Contents" />
  <rdfs:range rdf:resource="&rdfs;Literal"/>
  <rdf:type rdf:resource="&owl;FunctionalProperty" />
</owl:DatatypeProperty>

<owl:DatatypeProperty rdf:about="#contentLength">  
<!-- in bytes -->
  <rdfs:range rdf:resource="&xsd;nonNegativeInteger"/>
  <rdf:type rdf:resource="&owl;FunctionalProperty" />
</owl:DatatypeProperty>

<!-- 
    content composition

we don't need this class for our archive app but we will to content stored directly in a rdf kb as collection of smaller, content modules.  Here we an introduce the external contraint that the one-way digests of a ContentCollection are based the hash of the concatenations of the component hashes not the hash of the concatenation of the content itself -- but not for other types of digests because we don't want to break the similarity principle of nilsimsa
-->
<owl:Class rdf:ID="ContentCollection">
  <rdfs:subClassOf rdf:resource="#Contents" />
  <rdfs:subClassOf >  
  <owl:intersectionOf rdf:parseType="Collection">
      <owl:Restriction> <!-- disallow hasContents -->
          <owl:onProperty rdf:resource="#hasContents"/>
          <owl:cardinality rdf:datatype="&xsd;nonNegativeInteger">0</owl:cardinality>
      </owl:Restriction>
  </owl:intersectionOf>
  </rdfs:subClassOf>    
</owl:Class>

<owl:TransitiveProperty rdf:about="#includes" >  
<rdfs:domain rdf:resource="#ContentCollection" />
<rdfs:range rdf:resource="#Contents" />
</owl:TransitiveProperty>  

<owl:TransitiveProperty rdf:about="#included-by" >  
<rdfs:domain rdf:resource="#Contents" />
<rdfs:range rdf:resource="#ContentCollection" />
<owl:inverseOf rdf:resource="#includes"/>
</owl:TransitiveProperty>  

<!-- 
    content-instance & its properties 
    A content-instance deterministically yields a particular stream of bytes
-->
<owl:Class rdf:ID="ContentInstance">
<rdfs:subClassOf about="#ContentRep" />  
</owl:Class>

<owl:ObjectProperty rdf:about="#has-instance" >  
<rdfs:domain rdf:resource="#Contents" />
<rdfs:range rdf:resource="#ContentInstance" />
</owl:ObjectProperty>  

<owl:ObjectProperty rdf:about="#instance-of" >  
<rdfs:domain rdf:resource="#ContentInstance" />
<rdfs:range rdf:resource="#Contents" />
<owl:inverseOf rdf:resource="#has-instance"/>
</owl:ObjectProperty>  

<owl:DatatypeProperty rdf:about="#as-of">  
  <rdfs:domain rdf:resource="#ContentInstance" />
  <rdf:range rdf:resource="&xsd;dateTime"/>
</owl:DatatypeProperty>

<owl:ObjectProperty rdf:about="#from-source" >  
<rdfs:domain rdf:resource="#ContentInstance" />
<rdfs:range rdf:resource="#ContentSource" />
</owl:ObjectProperty>  

<owl:ObjectProperty rdf:about="#source-of" >  
<rdfs:domain rdf:resource="#content-source" />
<rdfs:range rdf:resource="#ContentInstance" />
<owl:inverseOf rdf:resource="#from-source"/>
</owl:ObjectProperty>  

<owl:ObjectProperty rdf:about="#transformed-by" >  
<rdfs:domain rdf:resource="#ContentInstance" />
<rdfs:range rdf:resource="#transform-routine" />
</owl:ObjectProperty>  

<!-- 
    Class routine and its subclasses & instances
        
    A routine is a deterministic operations that take a stream of bytes as input 
    TODO: rename!
-->

<owl:Class rdf:ID="routine" />

<owl:Class rdf:ID="transform-routine" >
<!-- a routine that deterministically outputs another stream of bytes -->
<rdfs:subClassOf rdf:about="#routine" />  
</owl:Class>

<owl:Class rdf:ID="transform-routine" /> 
<transform-routine about="#quote" />
<transform-routine about="#xdelta1.1-patch" />
<transform-routine about="#xdelta1.1-diff" />
<transform-routine about="#xslt" />

<transform-routine about="http://www.w3.org/TR/2001/REC-xml-c14n-20010315" >
<rdfs:label>Canonical XML (omits comments)</rdfs:label>
</transform-routine>

<transform-routine about="http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments" >
<rdfs:label>Canonical XML</rdfs:label>
</transform-routine>

<owl:Class rdf:ID="rdf-routine" >
<!-- a routine that deterministically outputs a set of RDF triples -->
<rdfs:subClassOf rdf:about="#routine" />  
</owl:Class>

<rdf-routine about="#xml-rdf" /> <!-- (treat input bytes as rdf-xml serialization, apply rdf-filter if present) -->
<rdf-routine about="#zip-as-rdf" /> <!-- (treat input bytes as a zip file, produce representation as content-container) -->

<!--  do we need this?
<owl:Class rdf:ID="xdelta-patch-instance" equivalent-to intersectionof content-instance restriction cardinality 1 transform-routine=xdelta-patch, and exists diff-file />
-->

<!-- 
    Class content-source and its subclasses and properties
-->
<owl:Class rdf:ID="ContentSource">
<!-- 
The location of a ContentSource isn't identified by its resource id but rather by its content-source-locator properties. This is because URL is not necessary universal and may need addition properties to get enough context to retrieve a sufficiently specific stream of bytes. Examples: of such properties are volume-name and host-name for a file scheme URL, or http-request-headers for an http scheme URL. These properties are indentified as being of type content-source-locator. -->
  <rdfs:subClassOf about="#ContentRep" />  
  <rdfs:subClassOf >  
  <owl:intersectionOf rdf:parseType="Collection">
      <owl:Restriction> <!-- require at least one content-source-locator property  -->
          <owl:onProperty rdf:resource="#content-source-locator"/>
          <owl:minCardinality rdf:datatype="&xsd;nonNegativeInteger">1</owl:cardinality>
      </owl:Restriction>
  </owl:intersectionOf>
  </rdfs:subClassOf>    
</owl:Class>

<rdfs:Property rdf:about="#content-source-locator" />

<owl:Class rdf:ID="RDFSource" >
<rdfs:subClassOf rdf:about="#ContentSource" />  
<!-- given a rdf query (just the resource url?) deterministically convert the result to a canonical stream of bytes  
issues: 
does the query language needs a notion of "this" e.g. content-source that denotes it?
need to apply ordering to result, 
literals: map to value? (esp. XMLLiteral canonization), 
inferences & entailments 
output format: rdf-xml? n3 triples? something else? invent a canonical-rdf-xml (like n3, defines order, canonical literal representation of datatype values (inc. xml canonization), and naming scheme for bnodes)
-->
</owl:Class>

<owl:Class rdf:ID="ContentLocation">
<rdfs:subClassOf about="#ContentRep" />  
</owl:Class>

<owl:Class rdf:ID="FileLocation" >
<rdfs:subClassOf rdf:about="#ContentLocation" />  
</owl:Class>

<owl:ObjectProperty rdf:about="#url">  
  <rdfs:domain rdf:resource="#ContentSource" />
  <rdf:range rdf:resource="#ContentLocation"/>
  <rdf:type rdf:resource="&owl;content-source-locator" />
  <rdf:type rdf:resource="&owl;FunctionalProperty" />
</owl:ObjectProperty>

<owl:Class rdf:ID="FileSource" >
<rdfs:subClassOf rdf:about="#ContentSource" />  
<!-- external constraint: url must be absolute file URL, if host name is not URL host-name property must be present -->
</owl:Class>

<!-- properties of FileSource -->
<owl:DatatypeProperty rdf:about="#host-name">  
  <rdfs:domain rdf:resource="#FileSource" />
  <rdfs:range rdf:resource="&rdfs;Literal"/>
  <rdf:type rdf:resource="&owl;content-source-locator" />
  <rdf:type rdf:resource="&owl;FunctionalProperty" />
</owl:DatatypeProperty>

<owl:DatatypeProperty rdf:about="#volume-name">  
<!-- maybe a necessary identifier for removable media -->
  <rdfs:domain rdf:resource="#FileSource" />
  <rdfs:range rdf:resource="&rdfs;Literal"/>
  <rdf:type rdf:resource="&owl;content-source-locator" />
  <rdf:type rdf:resource="&owl;FunctionalProperty" />
</owl:DatatypeProperty>

<!-- file system classes -->

  <owl:Class rdf:ID="FSObject">
<!-- base-clase of File-System objects (files, folders, links) -->
</owl:Class>

<owl:Class rdf:ID="FSFile" >
<!-- a FSFile is not a FileLocation, nor a content-source because it only has a location relative to its parent -- its file-name. Really a just collection of metadata, but still its a ContentRep because you can make assertions about its content
-->
<rdfs:subClassOf rdf:about="#FSObject" />  
<rdfs:subClassOf rdf:about="#ContentRep" />  
</owl:Class>

<owl:Class rdf:ID="FSLink"> 
<!-- e.g. symbolic links, mount points. maybe shortcuts, hard links? 
todo: link property range: FSObject -->
<rdfs:subClassOf rdf:about="#FSObject" />  
</owl:Class>

<owl:Class rdf:ID="FSFolder">
<rdfs:subClassOf rdf:about="#FSObject" />  
</owl:Class>

<owl:TransitiveProperty rdf:about="#contains" >  
<rdfs:domain rdf:resource="#FSFolder" />
<rdfs:range rdf:resource="#FSObject" />
</owl:TransitiveProperty>  

<owl:TransitiveProperty rdf:about="#contained-by" >  
<rdfs:domain rdf:resource="#FSObject" />
<rdfs:range rdf:resource="#FSFolder" />
<owl:inverseOf rdf:resource="#contains"/>
</owl:TransitiveProperty>  

<!-- properties of file-objects -->

<owl:DatatypeProperty rdf:about="#file-name">  
  <rdfs:domain rdf:resource="#FSObject" />
  <rdfs:range rdf:resource="&rdfs;Literal"/>
  <rdf:type rdf:resource="&owl;FunctionalProperty" />
</owl:DatatypeProperty>

<owl:DatatypeProperty rdf:about="#last-modified">  
  <rdfs:domain rdf:resource="#FSObject" />
  <rdf:range rdf:resource="&xsd;dateTime"/>
  <rdf:type rdf:resource="&owl;FunctionalProperty" />
</owl:DatatypeProperty>

<owl:DatatypeProperty rdf:about="#created-on">  
  <rdfs:domain rdf:resource="#FSObject" />
  <rdf:range rdf:resource="&xsd;dateTime"/>
  <rdf:type rdf:resource="&owl;FunctionalProperty" />
</owl:DatatypeProperty>

<owl:DatatypeProperty rdf:about="#last-modified">  
  <rdfs:domain rdf:resource="#FSObject" />
  <rdf:range rdf:resource="&xsd;dateTime"/>
  <rdf:type rdf:resource="&owl;FunctionalProperty" />
</owl:DatatypeProperty>

<owl:DatatypeProperty rdf:about="#attributes">  
  <rdfs:domain rdf:resource="#FSObject" />
  <rdfs:range rdf:resource="&rdfs;Literal"/>
  <rdf:type rdf:resource="&owl;FunctionalProperty" />
</owl:DatatypeProperty>

<owl:DatatypeProperty rdf:about="#posix-owner">  
  <rdfs:domain rdf:resource="#FSObject" />
  <rdfs:range rdf:resource="&rdfs;Literal"/>
  <rdf:type rdf:resource="&owl;FunctionalProperty" />
</owl:DatatypeProperty>

<owl:DatatypeProperty rdf:about="#posix-group">  
  <rdfs:domain rdf:resource="#FSObject" />
  <rdfs:range rdf:resource="&rdfs;Literal"/>
  <rdf:type rdf:resource="&owl;FunctionalProperty" />
</owl:DatatypeProperty>

<owl:DatatypeProperty rdf:about="#file-size">  
<!-- in bytes. As reported by the file system. Note that this may be different from content-length -->
  <rdfs:range rdf:resource="&xsd;nonNegativeInteger"/>
  <rdf:type rdf:resource="&owl;FunctionalProperty" />
</owl:DatatypeProperty>

<!-- 
    digest properties
-->

<owl:DatatypeProperty rdf:about="#digest">  
<!-- but why bother with the range when don't gain much and then you'll need to use rdf:dataType in every instance
  <rdf:range rdf:resource="&xsd;hexBinary"/>
-->
   <rdfs:range rdf:resource="&rdfs;Literal"/>
</owl:DatatypeProperty>

<owl:DatatypeProperty rdf:ID="nilsimsa">
<rdfs:subPropertyOf rdf:resource="#digest" />
<!-- hex digits -->
<rdf:type rdf:resource="&owl;FunctionalProperty" />
</owl:DatatypeProperty>

<owl:DatatypeProperty rdf:ID="oneway-digest">
<rdfs:subPropertyOf rdf:resource="#digest" />
</owl:DatatypeProperty>

<owl:DatatypeProperty rdf:ID="sha1-digest">
<rdfs:subPropertyOf rdf:resource="#oneway-digest" />
<rdf:type rdf:resource="&owl;FunctionalProperty" />
<!-- base64 -->
<!-- really this is an inverse functional property but it's also a DatatypeProperty but we don't declare this so we're not restricted to owl full -->
</owl:DatatypeProperty>

<owl:DatatypeProperty rdf:ID="md5-digest">
<rdfs:subPropertyOf rdf:resource="#oneway-digest" />
<rdf:type rdf:resource="&owl;FunctionalProperty" />
<!-- base64 -->
<!-- really this is an inverse functional property but it's also a DatatypeProperty but we don't declare this so we're not restricted to owl full -->
</owl:DatatypeProperty>

<owl:DatatypeProperty rdf:ID="hmac-digest">
<rdfs:subPropertyOf rdf:resource="#oneway-digest" />
<rdf:type rdf:resource="&owl;FunctionalProperty" />
<!-- really this is an inverse functional property but it's also a DatatypeProperty but we don't declare this so we're not restricted to owl full -->
</owl:DatatypeProperty>

<!-- 
generic metadata for any ContentRep
 -->
<owl:DatatypeProperty rdf:about="#content-type">  
<!-- mime-type. use dc or some other standard?  -->
  <rdfs:domain rdf:resource="#ContentRep"/>
  <rdfs:range rdf:resource="&rdfs;Literal"/>
  <rdf:type rdf:resource="&owl;FunctionalProperty" />
</owl:DatatypeProperty>

<owl:ObjectProperty rdf:about="#byte-rep-of" >  
<!-- short-cut for making assertions about the content: implies raw bytes (#quote) "transformation" -->
<!-- make subproperty of instance-of? -->
<rdfs:domain rdf:resource="#ContentRep" />
<rdfs:range rdf:resource="#Contents" />
<rdf:type rdf:resource="&owl;FunctionalProperty" />
</owl:ObjectProperty>  

<!--
provisional folderinstance class. doesn't quite fit into our schema (which need to be generalized a bit to fit this)
we're currently using this as the domain of instanceof and source-url and with invalid range classes
-->
<owl:Class rdf:ID="FolderInstance">
<rdfs:subClassOf about="#ContentInstance" />  
</owl:Class>

</rdf:RDF>


