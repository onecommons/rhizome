<xu:modifications version="1.0" xmlns:xu="http://www.xmldb.org/xupdate"
		    xmlns:a="http://rx4rdf.sf.net/ns/archive#" 
		    xmlns:wiki="http://rx4rdf.sf.net/ns/wiki#" 
		    xmlns:f = 'http://xmlns.4suite.org/ext' 
		    xmlns:wf='http://rx4rdf.sf.net/ns/raccoon/xpath-ext#'		    
		    xmlns:request-header = 'http://rx4rdf.sf.net/ns/raccoon/http-request-header#'
			xmlns:auth="http://rx4rdf.sf.net/ns/auth#"
			xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
			xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#' >

    <xu:if test='$itemname and not(wf:get-metadata("__noConflictDetection")) and 
                number($startTime) &lt; /*[wiki:name=$itemname]/a:last-modified'>
        <xu:message text="Conflict: Item has been modified after you started editing this item!" terminate="yes" />
    </xu:if>

    <xu:if test="not($__user/auth:has-role='http://rx4rdf.sf.net/ns/auth#role-superuser')">        
        <!-- we don't support fine-grained authentication yet for RxUpdate yet so let's block the most egrarious security holes 
            you can remove this check if you trust your users, etc.
         -->
        <xu:if test="$format = 'http://rx4rdf.sf.net/ns/wiki#item-format-python' and
             not(/*[.=concat($BASE_MODEL_URI, 'execute-python-token')][.=$__user/auth:has-rights-to/* or .=$__user/auth:has-role/*/auth:has-rights-to/*])">
            <xu:message text="You ({$__user/wiki:login-name}) don't have permission to create a page with format {$format}" terminate="yes" />
        </xu:if>
    
        <xu:if test="$format = 'http://rx4rdf.sf.net/ns/wiki#item-format-rxupdate' and
             not(/*[.=concat($BASE_MODEL_URI, 'execute-rxupdate-token')][.=$__user/auth:has-rights-to/* or .=$__user/auth:has-role/*/auth:has-rights-to/*])">
            <xu:message text="You ({$__user/wiki:login-name}) don't have permission to create a page with format {$format}" terminate="yes" />
        </xu:if>
    </xu:if>
    
    <xu:variable name='current-time' select="wf:current-time()"/>

    <!-- if anonymous was selected treat the itemname as the folder path 
         if no itemname was specified assume the item is anonymous
         in either case, we create a name based on the current time
     -->    
    <xu:variable name='isAnonymous' select="wf:get-metadata('anonymous') or not($itemname)"/>
    
    <xu:if test="wf:get-metadata('anonymous') and $itemname">
        <xu:if test="substring($itemname, string-length($itemname)) != '/'">
            <xu:variable name='itemname' select="concat($itemname, '/')" />
        </xu:if>
        <xu:variable name='itemname' select="concat($itemname, translate(f:pytime-to-exslt($current-time), ':', '_') )" />        
    </xu:if>
    <xu:if test="not($itemname)">
        <xu:variable name='itemname' select="translate(f:pytime-to-exslt($current-time), ':', '_')" />
    </xu:if>
    <!-- update the external metadata context with the possibly new itemname value -->
    <xu:if test="wf:assign-metadata('itemname', $itemname)" />
    
    <xu:variable name='resource' select='/*[wiki:name=$itemname]' />
        
    <xu:variable name = 'contents' select="f:if($file, $file, $contents)" />

    <xu:define-template name='getOrCreateFolder'>
    <!--
    requires 2 variables to be set: $folderPath and $parentName (initial value should be an empty string)
    exits with $folder set to the deepest folder resource    
    -->
    
      <!-- get the next segment: the substring stopping at the next / after parentName -->
      <xu:variable name='folderName' select="concat($parentName, substring-before( substring($folderPath, string-length($parentName)+1 ), '/'))" />
      <xu:if test='$folderName != $parentName'>  <!-- stop at the last segment (we assume its not a folder) -->
          <xu:variable name='folder' select='/wiki:Folder[wiki:name=$folderName]'/>            
          <xu:if test='not($folder)'>
              <xu:append select='/'>
                <!-- the final slash is there to distinguish it from a a:NamedContent resource with the same URI,
                     it has no impact on URI resolution
                -->
                <wiki:Folder rdf:about='{wf:get-nameURI($folderName)}/' >
                  <wiki:name><xu:value-of select="$folderName" /></wiki:name>
                </wiki:Folder>
              </xu:append>
              <!-- now that we've created it, rebind the variable -->
              <xu:variable name='folder' select='/wiki:Folder[wiki:name=$folderName]'/>
              
              <xu:if test='$parentName'>
                   <!-- removes trailing slash from parentName and the folder with that name -->
                  <xu:variable name='parentFolder' select='/wiki:Folder[wiki:name=substring($parentName, 1, string-length($parentName)-1)]'/>
                  <xu:append select='$parentFolder'>
                      <wiki:has-child>
                        <xu:attribute name="rdf:resource"><xu:value-of select="$folder"/></xu:attribute>
                      </wiki:has-child>
                  </xu:append>             
              </xu:if>          
          </xu:if>
          <xu:variable name='parentName' select="concat($folderName, '/')"/>            
          <xu:call-template name='getOrCreateFolder'/>                        
      </xu:if>          
    </xu:define-template>
    
    <!-- if the wikiname does not exist, add it now -->    
    <xu:if test='not($resource)'>
        <xu:append select='/'>
			<a:NamedContent>
			<xu:attribute name="rdf:about"><xu:value-of select="wf:get-nameURI($itemname)"/></xu:attribute>
			<wiki:name><xu:value-of select="$itemname" /></wiki:name>
			<xu:if test='$isAnonymous'>
			  <wiki:name-type rdf:resource='{uri("wiki:name-type-anonymous")}'/>
			</xu:if>
			<!-- add empty list resource that will be appended to below -->
			<wiki:revisions><rdf:List/></wiki:revisions>			
			</a:NamedContent>
        </xu:append>
        <!-- now that we've created it, rebind the variable -->
        <xu:variable name='resource' select='/*[wiki:name=$itemname]' />
                
        <xu:if test='contains($itemname, "/")'>
          <xu:variable name='folderPath' select="$itemname" />
          <xu:variable name='parentName' select='""'/>
          <xu:call-template name='getOrCreateFolder'/>
          <xu:append select='$folder'>
              <wiki:has-child rdf:resource='{$resource}'/>
          </xu:append>          
        </xu:if>
    </xu:if>
    
    <!-- do this check now, before we call a function that might save content or patches to disk -->
    <xu:if test='wf:get-metadata("label")'>
      <xu:if test='wf:find-unauthorized($__user, "http://rx4rdf.sf.net/ns/auth#permission-add-statement", 
              $resource, "http://rx4rdf.sf.net/ns/wiki#has-label", $label)' >
        <xu:message terminate='yes'
          text='Authorization error: you do not have rights to set this label: "{/*[.=$label]/rdfs:label}" - go back and choose another (or none).' />
      </xu:if>            
    </xu:if>            
        
    <!-- add or update last modified -->
    <xu:remove select='$resource/a:last-modified'/> 
    <xu:append select='$resource'>
        <a:last-modified><xu:value-of select="$current-time"/></a:last-modified>
    </xu:append>

    <!-- set access control: remove previous, add selected, if any -->
    <xu:remove select='$resource/auth:guarded-by'/>
    <xu:if test="wf:get-metadata('authtoken')"> 
       <xu:append select='$resource'>    
         <auth:guarded-by rdf:resource='{$authtoken}'/>
       </xu:append>
    </xu:if>

    <xu:define-template name='addKeyword'>
       <xu:variable name='kwUri' select="wf:evaluate('uri($kw)')" /> 
       <xu:append select='$resource'>  
         <wiki:about rdf:resource='{$kwUri}' />         
       </xu:append>      
       
       <xu:if test='not(/wiki:Keyword[.=$kwUri])'>
           <!-- not found, add a keyword resource -->
           <xu:append select='/'>
             <wiki:Keyword rdf:about='{$kwUri}'>
                <wiki:name>keywords/<xu:value-of select="$kw"/></wiki:name>
             </wiki:Keyword>
           </xu:append>
       </xu:if>
    </xu:define-template>
        
    <xu:if test='wf:has-metadata("keywords")'>                
         <xu:remove select='$resource/wiki:about'/>
         <xu:for-each select='wf:split(wf:get-metadata("keywords"))'>
           <xu:if test='string($current)'>
             <!-- in case the user used commas -->
             <xu:for-each select='wf:split($current, ",")'>
                <xu:if test='string($current)'>
                    <!-- if the keyword doesn't have a prefix put it in the 'kw' namespace  
                    we url escape the keyword in case the specified name has invalid characters
                    -->            
                   <xu:variable name='kw' select="f:if(contains($current,':') , 
                        $current, concat('kw:', f:escape-url($current)) )" />
                   <xu:call-template name='addKeyword'/>
                </xu:if> 
             </xu:for-each>      
           </xu:if>
         </xu:for-each>
    </xu:if>    
           
    <xu:variable name="formatTransformURI" select="wf:generate-bnode()"/>                
    
    <!-- don't bother saving the last revision if this was just a minor edit
    todo: this doesn't delete the actual contents if stored in an external file

    we disallow minor edit logic if the previous revision was edited by a different user or we're the guest user
    (instead we add a minor-edit property to mark the revision as minor)
    todo: if the user is guest allow a minor revision if remote-host and remote-host = last revision's remote host 
    -->
    <xu:variable name='replaceRevision' select="wf:get-metadata('minor_edit') and 
       not($__user/auth:has-role='http://rx4rdf.sf.net/ns/auth#role-guest') and 
       (not($resource/wiki:revisions/*) or ($resource/wiki:revisions/*/rdf:first/*)[last()]/wiki:created-by = $__user)" /> 

   <!-- check if the label is draft and there was a non-draft previous revision -->   
   <xu:variable name='draftAndPreviousNonDraft' select='wf:get-metadata("label") and /*[.=wf:get-metadata("label")]/wiki:is-draft and     
         $resource/wiki:revisions/*/rdf:first/*[not(wiki:has-label/*/wiki:is-draft)]' />
   <xu:if test='$draftAndPreviousNonDraft' >
      <xu:variable name='revnumber' select='count($resource/wiki:revisions/*/rdf:first/*)+number(not($replaceRevision))' />
      <xu:message terminate='no'
          text="Note: This revision was given a draft label and so will not be displayed by default.
          &lt;br/>You can view this revision using this URL:
          &lt;a href='site:///{$itemname}?revision={$revnumber}'>{$itemname}?revision={$revnumber}&lt;/a>." />
   </xu:if>            

   <!-- do these checks before we add or replace the revision -->
   <!-- if no label or label is not release check if there's previous revision that was released -->   
   <xu:if test='not($draftAndPreviousNonDraft) and (not(wf:get-metadata("label")) 
         or not(/*[.=wf:get-metadata("label")]/wiki:is-released)) and     
         $resource/wiki:revisions/*/rdf:first/*[wiki:has-label/*/wiki:is-released]' >
      <xu:variable name='revnumber' select='count($resource/wiki:revisions/*/rdf:first/*)+number(not($replaceRevision))' />
      <xu:message terminate='no'
          text="Note: This revision will not be displayed by default because it doesn't have a released label but a previous revision does.
          &lt;br/>You can view this revision using this URL:
          &lt;a href='site:///{$itemname}?revision={$revnumber}'>{$itemname}?revision={$revnumber}&lt;/a>." />
   </xu:if>            

    <!-- select the raw content of the latest revision by getting the last (deepest) resource with a 'a:contents' predicate 
         save this (and its digest) now because we might remove it below
    -->         
    <xu:variable name = 'lastContents' select="( ($resource/wiki:revisions/*/rdf:first/*)[last()]//a:contents)[last()]" />
    <xu:variable name = 'lastContentsDigest' select="$lastContents/*/a:sha1-digest" />
    
    <xu:if test='$replaceRevision'>        
        <!-- for simplicity's sake we implement this by just removing the last revision 
        before we add the new revision 
        We must do this before any possible patching because we may need to re-generate the last patch
        -->                
        <xu:remove select='id($lastContents/*)'/>
        <xu:remove select='($resource/wiki:revisions/*/rdf:first)[last()]'/>
    </xu:if>
        
    <xu:if test='not($replaceRevision)'>    
        <!-- 
        remove previous revision's wiki:alt-contents
        otherwise, retrieving a previous revision would get the latest content sitting in wiki:alt-contents        
        -->
        <xu:remove select='$lastContents/*/wiki:alt-contents'/>
                
        <!-- we create a reverse diff 
        by replacing the last revision's content with a diff between it and the new revision 
        note that we need to do this before we add the new revision
        -->                  
        
        <!-- 
        we want to do diffs on the raw content so if the previous revision stored its content at base64 encoding, 
        decode it before diffing
        -->
        <xu:variable name = 'base64decode' select="$lastContents/../a:transformed-by = 'http://www.w3.org/2000/09/xmldsig#base64'" />
                
        <xu:variable name = 'patch' select="wf:generate-patch($contents, $lastContents/.., $base64decode)" />
        
        <xu:if test='$patch'>
            <!-- 
            if the previous revision stored its content as base64 encoded, we need to replace the base64 decode transform also
            Likewise if previous revision was a patch (which will be true with a minor edit, since we just removed the latest revision)
            -->            
            <xu:variable name = 'isPatch' select="$lastContents/../a:transformed-by = 'http://rx4rdf.sf.net/ns/content#pydiff-patch-transform'" />            
            <xu:variable name = 'replaceContents' select="f:if($base64decode or $isPatch, $lastContents/../../.., $lastContents)" /> 
             
            <xu:replace select='$replaceContents'>
              <a:contents>
                <a:ContentTransform>                    
                    <a:transformed-by rdf:resource='http://rx4rdf.sf.net/ns/content#pydiff-patch-transform' />
                    <a:contents><xu:copy-of select='$patch'/></a:contents>
                    <a:pydiff-patch-base>
                        <!-- this points to the resource that whose contents we will apply the patch to, 
                        i.e. the contents of the revision we're about to add
                        At first it will point the resource whose has-contents predicate has raw content as its object
                        But as we add revisions we replace that raw content with patch transforms, thus creating a chain of patches to apply
                        -->
                        <xu:attribute name="rdf:resource">
                            <xu:value-of select="$formatTransformURI"/> 
                        </xu:attribute>
                   </a:pydiff-patch-base>
                </a:ContentTransform>
              </a:contents>
           </xu:replace>           
        </xu:if>                 
    </xu:if>
        
<!--
    this is how the above patching logic plays itself out given base64 encoded content:
    
    given revision 1 contents:    
        format -> base64decode A -> content A
    
    add revision 2:
        revision 2 = format -> base64decode B -> content B
        
    replace revision 1 base64decode A -> content A with patch + reference to revision 2
    so revision 1 = 
        format -> (patch -base-> base64decode B -> content B)
    
    add revision 3
    revision 2 base64decode B -> content B is replaced with 
    (patch -base-> base64decode C -> content C)
    
    thus revision 1 now looks like 
    format -> (patch -base-> (patch -base-> base64decode C -> content C))    
-->
        
    <!-- add the new revision -->
    <xu:append select='$resource/wiki:revisions/*'>
      <rdf:first>
         <wiki:Item>
            <xu:variable name="itemURI" select="wf:generate-bnode()"/>
            <xu:attribute name="rdf:about"><xu:value-of select="$itemURI"/></xu:attribute>
            <a:contents>
                <a:ContentTransform>
                   <xu:attribute name="rdf:about"><xu:value-of select="$formatTransformURI"/></xu:attribute>
                   <a:transformed-by><xu:attribute name="rdf:resource"><xu:value-of select="$format"/></xu:attribute>
                   </a:transformed-by>
                   <a:contents>
                     <xu:copy-of select="wf:save-contents($itemname, $format, $contents,
                                    count($resource/wiki:revisions/*/rdf:first)+1, $resource, 
                                    $title, string($lastContents), string($lastContentsDigest))"/> 
                   </a:contents>
               </a:ContentTransform>
           </a:contents>
            
            <wiki:item-disposition>
                <xu:attribute name="rdf:resource"><xu:value-of select="$disposition"/></xu:attribute>
            </wiki:item-disposition>
            
            <xu:if test='wf:get-metadata("doctype")'>
                <wiki:doctype><xu:attribute name="rdf:resource"><xu:value-of select="$doctype"/></xu:attribute></wiki:doctype>
            </xu:if>
            <xu:if test='$title'>
                <wiki:title><xu:value-of select="$title"/></wiki:title>
            </xu:if>
            <xu:if test='not($title) and $resource/wiki:name-type = uri("wiki:name-type-anonymous")'>
                <!-- the user didn't specify a name or title, so select the first line of text so we have something to show  -->
                <wiki:auto-summary><xu:value-of select="substring($contents, 1, 80)"/></wiki:auto-summary>
            </xu:if>
            <xu:if test="wf:get-metadata('change_comment')">
                <rdfs:comment><xu:value-of select="$change_comment"/></rdfs:comment>
            </xu:if>
            <xu:if test='wf:get-metadata("label")'>
              <wiki:has-label rdf:resource="{$label}"/>
            </xu:if>            
            <a:created-on><xu:value-of select="$current-time"/></a:created-on>
            <wiki:created-from><xu:value-of select="wf:if(wf:has-metadata('request-header:remote-host'), 
                                '$request-header:remote-host','$request-header:remote-addr')"/>
            </wiki:created-from>
            <wiki:created-by rdf:resource="{$__user}"/>
            <xu:if test='not($replaceRevision) and wf:get-metadata("minor_edit")'>
                <wiki:minor-edit>1</wiki:minor-edit>
            </xu:if>            
        </wiki:Item>
       </rdf:first>
    </xu:append>
    
    <xu:variable name='frameid' select="wf:assign-metadata('frameid', $current-time)" /> <!-- used by the iframe-display-handler -->                            
</xu:modifications>