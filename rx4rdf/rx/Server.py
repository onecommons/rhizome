##################################################################
# This module is based on code generated by CherryPy-0.8
# For more information about CherryPy, see http://www.cherrypy.org
##################################################################

_debugFile='server.dbg'
configFileName='server.cfg'
_debug=0
_outputFile="Server.py"
_cacheMap={}

import string, time, urllib, sys, getopt, cgi, socket, os, ConfigParser

_lastCacheFlushTime=time.time()
_stdout=sys.stdout

def debug(debugStr):
	if _debug:
		f=open(_debugFile, 'a')
		f.write(debugStr+'\n')
		f.close

#def printUsageAndExit():
#	print "Usage: server [-C configFile]"
#	sys.exit(-1)

if not globals().has_key('hotReload'):	
	#if not (len(sys.argv)==1 or (len(sys.argv)==3 and sys.argv[1]=="-C")): printUsageAndExit()	
	#if len(sys.argv)==3: configFileName=sys.argv[2]		
	try:	
		configFileName=sys.argv[sys.argv.index("-s")+1] #todo: splice argv at '-a'
	except (IndexError, ValueError):
		pass
	configFile=ConfigParser.ConfigParser()
	configFile.read(configFileName)

recordRequests = False
requestRecordFilePath = ''
requestsRecord = []
root = None
try:
    import cPickle
    pickle = cPickle
except ImportError:
    import pickle

def initRequest():
	pass
def initNonStaticRequest():
	pass
def initResponse():
	pass
def initNonStaticResponse():
	pass
def initServer():
	pass
def hotReloadInitServer():
	pass

def onError():
	import traceback, StringIO
	bodyFile=StringIO.StringIO()
	traceback.print_exc(file=bodyFile)
	response.body=bodyFile.getvalue()
	bodyFile.close()
	response.headerMap['content-type']='text/plain'
	if request.isXmlRpc:
		# Special case for XML-RPC:
		response.body=xmlrpclib.dumps(xmlrpclib.Fault(1, response.body))
		response.headerMap['content-type']='text/xml'

def logMessage(message):
	if logToScreen: print message
	if logFile:
		f=open(logFile, "a")
		f.write(message+"\n")
		f.close()
#maskAndViewMap={'root': {'footer': 1, 'header': 1, 'index': 1, 'edit': 1, 'save': 1, 'list': 1, 'view': 1}}
if not globals().has_key('hotReload'):
	##################################
	# Parse configuration file to get deployment option
	##################################
	
	# Default values for all parameters
	
	logToScreen=1 # Should logs be output to screen or not
	logFile="" # Default log file
	
	# Parameters used to tell which socket the server should listen on
	# Note that socketPort and socketFile conflict wich each other: if one has a non-null value, the other one should be null
	socketPort=0
	socketFile='' # Used if server should listen on AF_UNIX socket
	
	# Parameters used to tell what kind of server we want
	# Note that numberOfProcesses, threading and forking conflict wich each other: if one has a non-null value, the other ones should be null (for numberOfProcesses, null means equal to one)
	fixedNumberOfProcesses=1 # Used if we want to fork n processes at the beginning. In this case, all processes will listen on the same socket (this only works on unix)
	threading=0 # Used if we want to create a new thread for each request
	forking=0 # Used if we want to create a new process for each request
	
	# Variables used to tell if this is an SSL server
	_sslKeyFile=""
	sslCertificateFile=""
	
	# Variable used to turn xmlRpc on
	_xmlRpc=0
	
	# Variable used to server static content
	staticContentList=[]
	
	# Variable used to flush cache
	_flushCacheDelay=0
	
	
	# Read parameters from configFile
	try: logToScreen=int(configFile.get('server', 'logToScreen'))
	except: pass
	try: logFile=configFile.get('server', 'logFile')
	except: pass
	try: socketPort=int(configFile.get('server', 'socketPort'))
	except: pass
	try: socketFile=configFile.get('server', 'socketFile')
	except: pass
	try: fixedNumberOfProcesses=int(configFile.get('server', 'fixedNumberOfProcesses'))
	except: pass
	try: threading=int(configFile.get('server', 'threading'))
	except: pass
	try: forking=int(configFile.get('server', 'forking'))
	except: pass
	try: _sslKeyFile=configFile.get('server', 'sslKeyFile')
	except: pass
	try: sslCertificateFile=configFile.get('server', 'sslCertificateFile')
	except: pass
	try: _xmlRpc=int(configFile.get('server', 'xmlRpc'))
	except: pass
	try:
		staticDirList=configFile.options('staticContent')
		for staticDir in staticDirList:
			staticDirTarget=configFile.get('staticContent', staticDir)
			staticContentList.append((staticDir, staticDirTarget))
	except: pass
	try: _flushCacheDelay=float(configFile.get('cache', 'flushCacheDelay'))
	except: pass
	
	# Output parameters so that user can visually check values
	logMessage("Reading parameters from %s ..."%configFileName)
	logMessage("Server parameters:")
	logMessage("  logToScreen: %s"%logToScreen)
	logMessage("  logFile: %s"%logFile)
	logMessage("  socketPort: %s"%socketPort)
	logMessage("  socketFile: %s"%socketFile)
	logMessage("  fixedNumberOfProcesses: %s"%fixedNumberOfProcesses)
	logMessage("  threading: %s"%threading)
	logMessage("  forking: %s"%forking)
	logMessage("  sslKeyFile: %s"%_sslKeyFile)
	logMessage("  sslCertificateFile: %s"%sslCertificateFile)
	logMessage("  xmlRpc: %s"%_xmlRpc)
	logMessage("  flushCacheDelay: %s min"%_flushCacheDelay)
	logMessage("  staticContent: %s"%staticContentList)
	
	# Check that parameters are correct and that they don't conflict with each other
	if socketFile and not hasattr(socket, 'AF_UNIX'): raise "CherryError: Configuration file has socketFile, but this is only available on Unix machines"
	if fixedNumberOfProcesses!=1 and not hasattr(os, 'fork'): raise "CherryError: Configuration file has fixedNumberOfProcesses, but forking is not available on this operating system"
	if forking and not hasattr(os, 'fork'): raise "CherryError: Configuration file has forking, but forking is not available on this operating system"
	if _sslKeyFile:
		try: from OpenSSL import SSL
		except: raise "CherryError: PyOpenSSL 0.5.1 or later must be installed to use SSL. You can get it from http://pyopenssl.sourceforge.net"
	if _xmlRpc:
		try: import xmlrpclib
		except: raise "CherryError: xmlrpclib must be installed to use XML-RPC. It is included in Python-2.2 and higher, or else you can get it from http://www.pythonware.com"
	if socketPort and socketFile: raise "CherryError: In configuration file: socketPort and socketFile conflict with each other"
	if not socketFile and not socketPort: socketPort=8000 # Default port
	if fixedNumberOfProcesses==1: severalProcs=0
	else: severalProcs=1
	if severalProcs+threading+forking>1: raise "CherryError: In configuration file: fixedNumberOfProcesses, threading and forking conflict with each other"
	if socketPort and socketFile: raise "CherryError: Configuration file has socketPort and socketFile"
	if _sslKeyFile and not sslCertificateFile: raise "CherryError: Configuration file has sslKeyFile but no sslCertificateFile"
	if  sslCertificateFile and not _sslKeyFile: raise "CherryError: Configuration file has sslCertificateFile but no sslKeyFile"
	try: sys.stdout.flush()
	except: pass
	


# Create request and response instances (the same will be used all the time)
if not threading:
	# If we don't use threading, we don't care about concurrency issues among different requests
	class _emptyClass: pass
	request=_emptyClass()
	response=_emptyClass()
else:
	# If we use threading, we have to store request informations in thread-aware classes
	# TBC: we should probably set a few locks here and there, because we might still have concurrency issues otherwise
	# if thread switch happens at a bad time ...
	import thread
	class _threadAwareClass:
		def __init__(self):
			self.__dict__['threadMap']={} # Used to store variables. Keys are thread identifier
		def __setattr__(self, name, value):
			_myId=thread.get_ident()
			if not self.__dict__['threadMap'].has_key(_myId): self.__dict__['threadMap'][_myId]={}
			self.threadMap[_myId][name]=value
		def __getattr__(self, name):
			_myId=thread.get_ident()
			return self.__dict__['threadMap'][_myId][name]
	request=_threadAwareClass()
	response=_threadAwareClass()


_weekdayname=['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
_monthname=[None, 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']

if not globals().has_key('hotReload'):
	# Call initServer function
	logMessage("Calling initServer() ...")
	initServer()
else:
	# Call hotReloadInitServer function
	logMessage("Calling hotReloadInitServer() ...")
	hotReloadInitServer()
	logMessage("Hot reload finished")
	import sys
	sys.exit(0)
sys.stdout.flush()
if not globals().has_key('hotReload'):
	##################################
	# Common Service Code for CherryPy
	##################################
	import mimetypes
	mimetypes.types_map['.dwg']='image/x-dwg'
	mimetypes.types_map['.ico']='image/x-icon'
	
	def _parseFirstLine(data):
		request.path=data.split()[1]
		if request.path and request.path[0]=='/': request.path=request.path[1:] # Remove starting '/' if any
		request.browserUrl=request.path
		request.path=request.path.replace('&amp;', '&') # This case happens for some reason ...
	
		request.paramMap={}
		request.filenameMap={}
		request.paramTuple=()
		request.isXmlRpc=0
		i=request.path.find('?')
		if i!=-1:
			if request.path[i+1:]:
				for _paramStr in request.path[i+1:].split('&'):
					_sp=_paramStr.split('=')
					if len(_sp)==2:
						_key, _value=_sp
						_value=urllib.unquote_plus(_value)
						if request.paramMap.has_key(_key):
							# Already has a value: make a list out of it
							if type(request.paramMap[_key])==type([]):
								# Already is a list: append the new value to it
								request.paramMap[_key].append(_value)
							else:
								# Only had one value so far: start a list
								request.paramMap[_key]=[request.paramMap[_key], _value]
						else:
							request.paramMap[_key]=_value
			request.path=request.path[:i]
	
		if request.path and request.path[-1]=='/': request.path=request.path[:-1] # Remove trailing '/' if any
	
	def _parsePostData(_rfile):
		if _xmlRpc and request.path=="RPC2":
			# It's an XML-RPC call
			_data=_rfile.read(int(request.headerMap["content-length"]))
			request.isXmlRpc=1
			request.paramTuple,request.path=xmlrpclib.loads(_data)
		else:
			# It's a normal browser call
			_forms=cgi.FieldStorage(fp=_rfile, headers=request.headerMap, environ={'REQUEST_METHOD':'POST'}, keep_blank_values=1)
			for _key in _forms.keys():
				# Check if it's a list or not
				_valueList=_forms[_key]
				if type(_valueList)==type([]):
					# It's a list of values
					request.paramMap[_key]=[]
					for item in _valueList: request.paramMap[_key].append(item.value)
				else:
					# It's a single value
					# In case it's a file being uploaded, we save the filename in a map (user might need it)
					if _valueList.filename:
						request.filenameMap[_key]=_valueList.filename
					request.paramMap[_key]=_valueList.value
	
	def _insertIntoHeaderMap(key,value):
		request.headerMap[key.lower()]=value
		if key.lower()=='cookie':
			for _cookie in value.split('; '):
				try:
					_cookieKey, _cookieValue=_cookie.split('=')
					if _cookieValue and _cookieValue[0]=='"' and _cookieValue[-1]=='"': _cookieValue=_cookieValue[1:-1]
					request.cookieMap[_cookieKey]=_cookieValue
				except ValueError: pass
	
	def _doRequest(_wfile):
		try:
			_handleRequest(_wfile)
		except KeyboardInterrupt, e:
				print 'KeyboardInterrupt'
				onError()
				if requestRecordFilePath and requestsRecord:			
					requestRecordFile = file(requestRecordFilePath, 'w')
					pickle.dump(requestsRecord, requestRecordFile)
					requestRecordFile.close()							
		except:			
			try:
				onError()
				_wfile.write('HTTP/1.1 %s\r\n'%response.headerMap['status'])
				if response.headerMap.has_key('content-length') and response.headerMap['content-length']==0:
					response.headerMap['content-length']=len(response.body)
				for _key, _valueList in response.headerMap.items():
					if _key!='status':
						if type(_valueList)!=type([]): _valueList=[_valueList]
						for _value in _valueList:
							_wfile.write('%s: %s\r\n'%(_key, _value))
				_wfile.write('\r\n')
				_wfile.write(response.body)

			except:
				import traceback, StringIO
				_bodyFile=StringIO.StringIO()
				traceback.print_exc(file=_bodyFile)
				_body=_bodyFile.getvalue()
				_bodyFile.close()
				_wfile.write('HTTP/1.1 200\r\n')
				_wfile.write('Content-Type: text/plain\r\n')
				_wfile.write('\r\n')
				_wfile.write(_body)
				
	
	def _sendResponse(_wfile):
		# Save page in the cache if needed
		if hasattr(request, 'cacheKey') and request.cacheKey:
			_cacheMap[request.cacheKey]=(request.cacheExpire, response.headerMap, response.body)
	
		_wfile.write('HTTP/1.1 %s\r\n'%response.headerMap['status'])
		for _key, _valueList in response.headerMap.items():
			if _key!='status':
				if type(_valueList)!=type([]): _valueList=[_valueList]
				for _value in _valueList:
					#print "response header:", _key, ":", _value
					_wfile.write('%s: %s\r\n'%(_key, _value))
		_wfile.write('\r\n')
		_wfile.write(response.body)
	
	def _sendCachedPageIfPossible(_now,_wfile):
		if hasattr(request, 'cacheKey') and request.cacheKey:
			# Use caching for this page
			if _cacheMap.has_key(request.cacheKey) and _cacheMap[request.cacheKey][0]>=_now:
				# This page is already in the cache and it hasn't expired yet: use the cached version
				dummy, response.headerMap, response.body=_cacheMap[request.cacheKey]
				initResponse()
				request.cacheKey='' # No need to save the page in the cache again
				_sendResponse(_wfile)
				return 1
			# else:
			# 	Either the page has never been cached, or the cached version expired
			# 	In the case, we build the page normally and it will be saved in the cache
			#	in the _sendResponse function
		return 0
	
	def _handleRequest(_wfile):
		_now = time.time()
		_year, _month, _day, _hh, _mm, _ss, _wd, _y, _z = time.gmtime(_now)
		_date="%s, %02d %3s %4d %02d:%02d:%02d GMT"%(_weekdayname[_wd],_day,_monthname[_month],_year,_hh,_mm,_ss)
		response.headerMap={"status": 200, "content-type": "text/html", "server": "Rhizome 0.1", "date": _date, "set-cookie": [], "content-length": 0}
	
		if _sslKeyFile:
			request.base="https://"+request.headerMap['host']
		else:
			request.base="http://"+request.headerMap['host']
		request.browserUrl=request.base+'/'+request.browserUrl
	
		# Flush the cache if needed:
		global _lastCacheFlushTime
		if _flushCacheDelay and _cacheMap and _lastCacheFlushTime+_flushCacheDelay*60<=_now:
			_lastCacheFlushTime=_now
			for key, (expire, dummy, dummy) in _cacheMap.items():
				if expire<=_now:
					del _cacheMap[key]
	
		# Perform some initial operations (such as rewriting url ...)
		request.originalPath=request.path
		request.originalParamMap=request.paramMap
		request.originalParamTuple=request.paramTuple
	
		initRequest()
	
		_path=request.path
	
		# Handle static directories
		for urlDir, fsDir in staticContentList:
			if _path[:len(urlDir)+1]==urlDir+'/':
	
				if _sendCachedPageIfPossible(_now, _wfile): return
	
				f=open(fsDir+_path[len(urlDir):], 'rb')
				response.body=f.read()
				response.headerMap['content-length']=len(response.body)
				f.close()
				# Set content-type based on filename extension
				_i=_path.rfind('.')
				if _i!=-1: _ext=_path[_i:]
				else: _ext=""
				contentType=mimetypes.types_map.get(_ext, "text/plain")
				response.headerMap['content-type']=contentType
				initResponse()
				_sendResponse(_wfile)
				return
	
		initNonStaticRequest()
	
		if _sendCachedPageIfPossible(_now, _wfile): return
	
##		_path=request.path
##		# Special case when url is just the host name
##		if not _path: _path='index'
##	
##		# Work on path:
##		# a/b/c/d -> a_b_c.d()
##		# c -> root.c()
##	
##		if request.isXmlRpc: _pathList=_path.split('.')
##		else: _pathList=_path.split('/')
##		#print "_path:", _path
##		if len(_pathList)==1: _pathList=['root']+_pathList
##		_myClass='_'.join(_pathList[:-1])
##		_function=_pathList[-1]
##		#print "_myCass:", _myClass, "__function:", _function
##	
##		# Work on paramMap (or paramTuple if it's an XML-RPC call) to make it like python arguments
##		if request.isXmlRpc:
##			_paramStr=(`request.paramTuple`)[1:-1]
##		else:
##			_paramStr=","
##			for _key, _value in request.paramMap.items():
##				if type(_value)==type("") and _value[:11]=='"_instance_': # Special hack for CherryTable
##					_paramStr+="%s=cherryDb.getInstanceItem(%s),"%(_key, _value)
##				else:
##					_paramStr+="%s=%s,"%(_key,`_value`)
##			_paramStr=_paramStr[1:-1]
##		# Test that class exists and that function is a view or a mask
##		#if not maskAndViewMap.has_key(_myClass): raise 'CherryError: CherryClass "%s" doesn\'t exist'%_myClass
##		#elif not maskAndViewMap[_myClass].has_key(_function): raise 'CherryError: CherryClass "%s" doesn\'t have any view or mask method called "%s"'%(_myClass, _function)
##		# Call class member
##		if _paramStr:
##			_paramStr = ',' + _paramStr
##		response.body=eval("%s.handleRequest('%s',_request=request, _response=response%s)"%(_myClass,_function, _paramStr))

		if request.isXmlRpc:
			request.paramMap = dict( request.paramTuple)
			
		name = request.path[len(root.ROOT_PATH):] #assume we only get requests inside our home path
		if not name:
			name= 'index'
			
		request.paramMap['_request']=request
		request.paramMap['_response']=response
		if recordRequests:
			requestsRecord.append([ name, request.paramMap ])
		response.body=root.handleRequest(name, **request.paramMap)
	
		initResponse()
		initNonStaticResponse()
	
		if request.isXmlRpc:
			# Marshall the result if it's an XML-RPC call
			# Wrap the response into a singleton tuple
			response.body=(response.body,)
			response.body=xmlrpclib.dumps(response.body, methodresponse=1)
			# Response type is text/xml for an XML-RPC call
			response.headerMap["content-type"]="text/xml"
	
		if response.headerMap.has_key('content-length') and response.headerMap['content-length']==0:
			try: response.headerMap['content-length']=len(response.body)
			except TypeError: raise "CherryError: The mask or view didn't return a string !"
		_sendResponse(_wfile)
	
	"""CherryPy HTTP Server.
	
	This module builds on BaseHTTPServer in a fashion similar to SimpleHTTPServer 
	by implementing the standard GET and HEAD requests in a fairly straightforward manner.
	
	"""
	
	__all__ = ["CherryHTTPRequestHandler"]
	
	import BaseHTTPServer
	import mimetypes
	
	
	class CherryHTTPRequestHandler(BaseHTTPServer.BaseHTTPRequestHandler):
	
		"""CherryPy HTTP request handler with the following commands:
	
			o  GET
			o  HEAD
			o  POST
			o  HOTRELOAD
	
		"""
	
		def cook_headers(self):
			"""Process the headers in self.headers into the request.headerMap"""
			request.headerMap={}
			request.cookieMap={}
			for item in self.headers.items():
				_insertIntoHeaderMap(item[0],item[1])
			if not request.headerMap.has_key('remote-addr'):
				try:
					request.headerMap['remote-addr']=self.client_address[0]
					request.headerMap['remote-host']=self.address_string()
				except: pass
			logMessage("[%s] %s - %s"%((time.strftime("%Y/%m/%d %H:%M:%S")), request.headerMap.get('remote-addr', ''), self.raw_requestline[:-2]))
	
		def do_GET(self):
			"""Serve a GET request."""
			_parseFirstLine(self.raw_requestline)
			self.cook_headers()
			_doRequest(self.wfile)
	
		def do_HEAD(self): # TBC: head is not implemented yet
			"""Serve a HEAD request."""
			_parseFirstLine(self.raw_requestline)
			self.cook_headers()
			_doRequest(self.wfile)
	
		def do_POST(self):
			"""Serve a POST request."""
			_parseFirstLine(self.raw_requestline)
			self.cook_headers()
			_parsePostData(self.rfile)
			_doRequest(self.wfile)
	
		def do_HOTRELOAD(self):
			"""Serve a HOTRELOAD request."""
			if _debug:
				logMessage("Starting hot reload ...")
				sys.stdout.flush()
				global hotReload
				hotReload=1
				try: execfile(_outputFile)
				except SystemExit, e: pass
			else:
				logMessage("Hot reload disabled when not in debug mode ...")
	
		def setup(self):
			""" We have to override this to handle SSL (socket object from the OpenSSL package don't have the makefile method) """
			self.connection=self.request
			#self.rfile=self.connection.makefile('rb', self.rbufsize)
			#self.wfile=self.connection.makefile('wb', self.wbufsize)
			self.rfile=CherryFileObject(self.connection, 'rb', self.rbufsize)
			self.wfile=CherryFileObject(self.connection, 'wb', self.wbufsize)
	
		def log_message(self, format, *args):
			""" We have to override this to use our own logging mechanism """
			logMessage("%s - - [%s] %s\n" %
							 (self.address_string(),
							  self.log_date_time_string(),
							  format%args))
	
	
	# I'm a bit confused here: "some" sockets have a "sendall" method, some don't.
	# From my testing, the following sockets do have a "sendall" method:
	#	- Regular sockets in Python2.2 or higher
	#	- SSL sockets in pyOpenSSL-0.5.1 on Linux
	# The following sockets don't have a "sendall" method
	#	- Regular sockets in Python2.1 or lower
	#	- SSL sockets in pyOpenSSL-0.5.1 on Windows (doh)
	# So I'm just taking advantage of the sendall method when it's there. Otherwise, I'm using the good old way of doing it with "send" (but I'm afraid this might be blocking in some cases)
	class CherryFileObject(socket._fileobject):
		def flush(self):
			if self._wbuf:
				if hasattr(self._sock, "sendall"):
					self._sock.sendall(self._wbuf)
					self._wbuf=""
				else:
					while self._wbuf:
						_sentChar=self._sock.send(self._wbuf)
						self._wbuf=self._wbuf[_sentChar:]
	
	
	class CherryHTTPServer(BaseHTTPServer.HTTPServer):
		def __init__(self, server_address, RequestHandlerClass):
			# I know it says "do not override", but I have to in order to implement SSL support !
			SocketServer.BaseServer.__init__(self, server_address, RequestHandlerClass)
			if _sslKeyFile:
				self.socket=SSL.Connection(ctx, socket.socket(self.address_family, self.socket_type))
			else:
				self.socket=socket.socket(self.address_family, self.socket_type)
			self.server_bind()
			self.server_activate()
	
		def server_bind(self):
			# Removed getfqdn call because it was timing out on localhost when calling gethostbyaddr
			self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
			self.socket.bind(self.server_address)
	
	def run_server(HandlerClass, ServerClass, socketPort, socketFile, protocol="HTTP/1.1"):
		"""Run the HTTP request handler class."""
	
		if socketPort: server_address=('', socketPort)
		else:
			try: os.unlink(socketFile) # So we can reuse the socket
			except: pass
			server_address=socketFile
		HandlerClass.protocol_version = protocol
		httpd = ServerClass(server_address, HandlerClass)
		if socketFile:
			try: os.chmod(socketFile, 0777) # So everyone can access the socket
			except: pass
	
		if _sslKeyFile: servingWhat="HTTPS"
		else: servingWhat="HTTP"
		if socketPort: onWhat="socket port: %s"%socketPort
		else: onWhat="socket file: %s"%socketFile
		logMessage("Serving %s on %s"%(servingWhat, onWhat))
	
		# If fixedNumberOfProcesses is more than one, create new processes
		if fixedNumberOfProcesses>1:
			for i in range(fixedNumberOfProcesses):
				logMessage("Forking a kid")
				if not os.fork():
					# Kid
					httpd.serve_forever()
		else:
			httpd.serve_forever()
	
	# If SSL is used, perform some initialization
	if _sslKeyFile:
		# Setup SSL mode
		ctx=SSL.Context(SSL.SSLv23_METHOD)
		# ctx.set_options(SSL.OP_NO_SSLv2) # Doesn't work on Windows
		ctx.use_privatekey_file(_sslKeyFile)
		ctx.use_certificate_file(sslCertificateFile)
	
	
	import SocketServer
	if socketFile:
		# AF_UNIX socket
		if forking:
			class MyCherryHTTPServer(SocketServer.ForkingMixIn,CherryHTTPServer): address_family=socket.AF_UNIX
		elif threading:
			class MyCherryHTTPServer(SocketServer.ThreadingMixIn,CherryHTTPServer): address_family=socket.AF_UNIX
		else:
			class MyCherryHTTPServer(CherryHTTPServer): address_family=socket.AF_UNIX
	else:
		# AF_INET socket
		if forking:
			class MyCherryHTTPServer(SocketServer.ForkingMixIn,CherryHTTPServer): pass
		elif threading:
			class MyCherryHTTPServer(SocketServer.ThreadingMixIn,CherryHTTPServer):pass
		else:
			MyCherryHTTPServer=CherryHTTPServer

def start_server(serve, record = False, requestRecordPath = 'debug-wiki.pkl'):
	global root, recordRequests, requestRecordFilePath
	root = serve
	recordRequests = record
	requestRecordFilePath = requestRecordPath
	try:
		run_server(CherryHTTPRequestHandler,MyCherryHTTPServer,socketPort,socketFile)
	finally:
		if requestRecordFilePath and requestsRecord:			
			requestRecordFile = file(requestRecordFilePath, 'w')
			pickle.dump(requestsRecord, requestRecordFile)
			requestRecordFile.close()
