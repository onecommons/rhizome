 document:
  header:
   title: `Rhizome Manual
  body:
!Overview
Rhizome is a simple content management and delivery system that is similar to a [Wiki|http://c2.com/cgi/wiki] except that you can author arbitrary XML content and RDF metadata, including the structure of the website. This allows both the content and structure to be easily repurposed and complex web applications rapidly developed. 

The key conceptual difference is this: a Wiki is a website whose pages correspond to WikiNames, which are local to the website. Rhizome has a notion similar to WikiNames but they are universal, unique, abstract entities that don't necessarily correspond to a web page -- they can be a name for anything.  How they are displayed depends on the context, using the [Raccoon] engine.

The long-term [vision|RhizomeStatus] is that each Rhizome site will intertwine together, forming an emergent fuzzy taxonomy over a peer-to-peer network.

!!Features

Wiki ease

* All the functionality of a Wiki: public and automatic creation of pages and links using simple text formatting rules
* But the same [formatting rules|RhizML] can used to author arbitrary HTML, XML and RDF 
* And you can create and edit not just content but also the metadata, site structure and appearance, even application behavior
* Including dynamic pages: supports XSLT, [RxSLT], Python, [RxUpdate]
* Thus enabling dynamic, rule and context based presentation of content

Advanced Content Management functionality

* pages can consist of any content: xml, html, binary, etc.
* content, metadata and site structure is a stored as RDF: enabling it be repurposable, human editable, application agnostic, etc.
* flexible authorization and security model 
* staging/release workflow
* native versioning of content and metadata, conflict detection
* support for external resources that can be modified without cooperation
* can generate static websites
* import/export of content and metadata
* flexible backend: supports multiple RDF engines (Redland, 4Suite) with multiple datastores: file based, SQL databases, embeddable databases (Sleepycat, Metakit)

!!Key terms and concepts
Below are some terms (in alphabetical order) that are used through this manual.

+item=Somewhat informally, a resource that is content, specifically that of type NamedContent.
+model=The collection of resources and their properties that make up an instance of Rhizome. Generally refers to its logical representation, while //store// refers its physical location.
+object=In RDF, the value of a property
+predicate=In RDF, the name of a property
+property=A property consists of a name (a URI) and a value. //Resources// have properties.
+resource=A resource is an abstract name for something (anything). Rhizome treats everything as a resource with a set of //properties// and every resource is named with a //URI//.
+[Raccoon]=The application server that Rhizome runs on.
+[RDF]=Resource Description Framework -- the "native format" of Rhizome
+[RxML]=An alternative syntax for RDF which designed to be usable by even those ignorant of RDF.
+store=The physical location of the //model//. By default this is will be a text file, but you can configure Rhizome to use a variety of databases.
+subject=In RDF, the resource that a property applies to.
+URI=//U//nique //R//esource //I//dentifier, aka URL (except it doesn't have to work in your browser).
+WikiName=A name of a resource that is unique to the site and so can be used to link to that resource.
+[ZML]=An alternative syntax for XML that is designed to be relatively painless to author; similar to Wiki text formatting rules.

!Requirements
Rhizome requires Python 2.2 or later and [4Suite 1.0a1|http://4suite.org]. 

Rhizome is known to run on Linux, Windows NT & 2000, and Cygwin and should work on any platform that supports Python and 4Suite.

On Windows, [Win32 Extensions|http://www.python.org/windows/win32all] must be installed or interprocess file locking will be disabled (which is needed if you have multiple processes accessing the same model).

!Installation
This is a standard Python source distribution. To install:
# Unzip
# Run ^^python <unzip dir>/setup.py install^^

!Running
Rhizome is an application that runs on [Racoon], a simple application server.  Rhizome consists entirely of a Racoon config file and a bunch of web pages. To run Rhizome, run Racoon specifying your Rhizome config file using the -a option, e.g.: 

^^python racoon.py -a rhizome/rhizome-config.py^^

This will launch Racoon's built-in http server, which runs on port 8000 by default. You can change this by editing ^^server.cfg^^ (see the [Raccoon Manual] for more information). 

That's it! You now have a new instance of Rhizome running. By default, the site will be stored in the current directory in file called "wikistore.nt" and content will be stored in a subdirectory called "content".  Most of the Rhizome's behaviour is defined in its pages so you can start customizing your Rhizome instance by editing its pages and metadata from within Rhizome.

!!Initial Configuration
However, there are few additional things you might want to configure first if you're deploying a live website. First, you should create your own config file to seperate your config settings from the stock Rhizome config settings.  For example, the Rx4RDF distribution contains a copy of the rx4rdf.sf.net website;  here's the first couple of lines of its config file (^^site-config.py^^):

p'''BASE_MODEL_URI='http://rx4rdf.sf.net/site/'
__include__('../rhizome/rhizome-config.py')'''

The first line sets the base URI that will be used for all RDF resources created. Note that this does not have to correspond to any resolvable URL.
The second includes the Rhizome config file.

The next, you probably want to set administrator password and the secure hash seed.  Rhizome creates a default administrator super-user that has full access to the system, and its login name and password both default to 'admin'. To set your own password, in your config file set ^^ADMIN_PASSWORD^^ //before// including the Rhizome config. If you don't want to store the password in cleartext in your config file, you can set ^^ADMIN_PASSWORD_HASH^^ instead, which requires SHA1 digest of the concatenation of the password and the secure hash seed. In Python, you can calculate it like this: "import sha; sha.sha( 'yourpassword' + 'your secure hash seed').hexdigest()"

As illustrated above, the secure hash seed is used to generate a digest that be safely stored in a publically accessible mode. To set your own private seed, set the ^^SECURE_HASH_SEED^^ setting in your config file //before// including the Rhizome config. If you don't set your own private seed, or if it is compromised, it will be much easier to mount a dictionary attack on the password hashes. Note that if you change its value, all previously generated password hashes stored in your model will no longer work.

!!More Configuration
For information on configuring the Racoon application server, for example, to run it behind an Apache web server, see the [Raccoon Manual]. For complete documentation on all the settings available your config file see this sample [config file|RacoonConfig]. Other common configuration tasks include choosing a model store, setting the PATH to search for files, and setting the application's base URL. Note that for security, the ability to create executable Python pages is configured off by default.

!Using Rhizome

!!Creating and Editing Resources
You can create and edit any type of resource in Rhizome, but it is primarly focused on content item resources, which are internally called ^^NamedContent^^. If you click on the "New" or (most of the time) the "Edit" link on the default template you will see the edit page specific to this type of resource. To edit or create other types of resources, go to the [administration] page (the "Admin" link on the default template). There you will be able to view or manage any type of resource in the system. 

__Editing Content Items__

Below is a guide to the form controls found on the edit and new pages:

+Name=When creating content for the first time the Name edit box will be shown. Enter the name of the content here -- it should be a name unique to the site. If the name contains slashes (e.g. 'foo/bar') the content will placed in the folder based on name, creating the folder structure if necessary (e.g. content will be put in the folder named 'foo' and the content given the name 'bar'). If the "Anonymous" option is selected you do not need to give the content a name (internally it will be given a name based on the current time and date). If the "Anonymous"  selected //and// there is a name entered in the "Name" edit box, then the name will be treated as the folder path in which to place the anonymous content (creating the folder structure if necessary).

+Title=Enter the title for the content (optional). Unlike the name it can be changed anytime and contain any characters. 

+Content=You create the item's content either by entering it in the editbox or by uploading a file.

+Source Format=This dropdrown specifies the format of the content you are entering and drives how Rhizome will process the content. The following list describes how Rhizome will handle the different choices:
++Binary=Binary content is content such as an image or multimedia file. It is never tranforms or manipulated by Rhizome. Generally you'll want to set the Item Type (see below) to "Page".
++HTML/XML=HTML and XML text will have any link that starts with 'site:' replaced with a live URL depending on the request context. Using 'site:' links allows links on a page to be work even if the page moves to another directory or transformed in other contexts (such as statically exported). The 'site:' URL scheme is similar to the 'file' scheme: URLs that start with 'site:/\//' will be relative to the root of where the Rhizome site is running from, while URLs that start only with 'site:' will be relative to the current location of the page.
++Python=The contents is treated as [Python|www.python.org] code that is executed when the page is requested. (You might not see this option as it turned off by default.) Anything the code writes to ^^stdout^^ is captured and sent as the response.
++RxSLT=[RxSLT] is a XSLT sheetsheet that can create HTML or XML output using the site's model the stylesheet's source.
++RxUpdate=[RxUpdate] is an (enhanced) [XUpdate|http://xmldb.org/xupdate/] document that used to update the site's model. RxUpdate pages are typically used as form handlers (for example, 'save' page) and generally you'll want to set its Item Type to 'Handler'.
++Text=Plain text. When included in HTML (for example, by the "Entry" template), it will be escaped.
++XSLT=A [XSLT|http://w3.org/TR/xslt] stylesheet. It uses the current content of the request as the document source, so you'll need to set this page up as a template by added a "wiki:handles-doctype" property. You'll also probably want to set the Item Type to "Template".
++ZML=[ZML] is a text format similar to the ones found in Wikis except that you can use it author arbitrary HTML or XML.

+Output Document Type=This is specifies the type of XML document that will be outputed after the processing the source. It is used to select the stylesheet that will transform the output to HTML for rendering in your browser. By default Rhizome, supports HTML, DocBook and several Apache Forest schemas.

+Item Type=The Item Type (internally called the //Item Disposition//) specifies how this content item should be used. It is used to select a template stylesheet that will be applied to the content. The following are included by default:
++Page=This means that content is a stand-alone page and no template should be applied to it. For example, you probably want to set this for images.
++Entry=(the default). This frames the content in the default [site-template|site-template?action=edit].
++Handler=The content is used to update the site or handle a POST from a form page. Typically used for RxUpdate or Python pages that might not create any response output and for page that handle write actions for other types of resources. The default handler template just prints the message "Completed [action name] of [resource name]!"
++RxML Template=Indicates the content is text containing RxML that when invoked will bring up an edit metadata page containing the RxML. When saved, Rhizome will treate all the properties as new and replace any anonymous (aka //blank//) resources (those whose name start 'bnode:') with new anonymous resources. Using RxML templates provides a quick and dirty way of adding new types of resources to the sytem without to build a form UI for creating and editing them.
++Template=The content will be used as template (typically for XSLT content). Currently, this just effect of stopping any more templates from being applied to the content.

+Sharing=This dropdown let's you choose how the content can be accessed. Choices depend on rights the user has. The Guest user (the default if you are not logged in) only has one choice: "Public", which means anyone can view, edit or delete the content. If you sign in as a user, you'll see choices that allow to make content only readable and writable by you (and administrators), or public readable but only privately modifiable. You can also set the content to be readable and/or writable only to members of the user group you below to.

+Label=This dropdown shows all the labels in the system that you can choose to be applied to this revision of the content. The default configuration of Rhizome has two labels, "Draft" and "Release", with the latter being the default choice. To have no label associated, choosing the blank option. When viewing content, the last revisions with the "Release" label will be shown (if it exists, otherwise the last revision is choosen) -- unless a ^^label^^ or ^^revision^^ parameter is present in the URL. 

+Minor Edit=When you check this option you mark this revision of the content as being a minor edit. If you also edited the last revision of this item, then the current revision will replace the previous one. (This prevents cluttering the site up with revisions just fix typos, etc.)

__Assigning metadata and properties to the content__

After you save your changes, you can add or modify arbitary properties and metadata for the content item and its latest revision. To do so, after saving, choose the metadata link, which will display the metadata view of the content. Then choose the "Edit Metadata" at the top of the metadata view page.

The edit metadata page presents the content's resources as editable [RxML]. In addition to adding arbitrary metadata there are a few properties that affect Rhizomes behavior that are not managed by the edit page. 

+wiki:alias=This property can be assigned to any resource that uses the ^^wiki:name^^ property and lets you give a resource an alternative name. Its value is identical to the value of a ^^wiki:name^^: it may be hierarchical path that corresponds to its folder structure and the name should be unique across the site.

+wiki:handles-disposition=When creating a template, use this property to indicate that content items that have the specified item disposition should have this template applied to it. Its value is a Item Disposition resource.

+wiki:handles-doctype=When creating a template, use this property to indicate that content items that have the specified document type should have this template applied to it. Its value is a DocType resource.

+wiki:handles-action=This property, along with ^^wiki:action-for-type^^, indicates that this resource should be used to handle the specified action.

+wiki:action-for-type=Used along side ^^wiki:handles-action^^ to specify the types of resources this action handler should apply. Its value should be a resource type or ^^wiki:Any^^ (action handlers with the latter are lower priority than one that specifies a specific type).

__Creating and Editing Other Resources__

You can browser and edit all the types of resources in the system from the [Administration] page (click on the "Admin" link). Unless a resource type has an edit handler associated with it the default edit handler will be used, which lets you directly edit the resource as [RxML]. You can designate a resource as an edit handler for a given type of resource by assigning it the ^^wiki:handles-action^^ and ^^wiki:action-for-type^^ properties, as described above. 

There are a few useful properties that can be assigned to any resource:

+wiki:name=Any resource that has this property can be addressed with an URL, just like the item content name described above. Names should unique across the site, with the exception that you can also have a content item with the same name (and will be invoked instead). If the name is hierarchical, you should add a ^^wiki:has-child^^ property to the parent Folder. 

+wiki:alias=See above.

+rdfs:label=Many of Rhizomes pages check for this property when trying to display a human-readable name for a resource.

;todo: !!Browsing and Searching

!!Resources, actions and URLs

When you request an URL from Rhizome, translates the URL to an internal resource, applies an //action// to the resource, and returns the result of that action to your browser. The default action is 'view' but you specify other actions by adding an 'action' parameter to a URL (or, when creating an html form, by adding an 'action' form variable) -- for examples, look at the links such as 'Edit' or 'Revisions' at bottom of the default template. 

URLs are mapped to resources by through a series of steps:
# Find the source resource. Rhizome applies the following queries, stopping at the first match:
## If the URL has an 'about' parameter, find the resource whose URI matches the parameter's value.
## Look for a resource that has a ^^wiki:name^^ property that matches the URL's path.
## Look for a resource that has a ^^wiki:alias^^ property that matches the URL's path.
## Look in the directories in Rhizome's PATH setting for a file that matches the URL's path. If one is found none of the following steps apply and the contents of the file is returned immediately.
## Look for a resource that has a ^^wiki:name^^ property named '_not_found'. By default, this will be a page prompts you to create a new page using the missing name.
# See if the user is authorized to perform the action associated with this URL on the selected resource. If not, set the resource to ^^auth:Unauthorized^^.
# Look for a resource that can handle the action associated with this URL when applies to the selected resource.
## If the action is 'view' and resource is of type 'NamedContent', choose the same resource.
## Search for a resource with a ^^wiki:handles-action^^ property equal to the action and a ^^wiki:action-for-type^^ property equal to the type of the current resource or 'wiki:Any'.
## Look for a resource that has a ^^wiki:name^^ property named 'default-resource-viewer'. The default view displays the resource as [RxML].
# At this point the current resource should alway be of type NamedContent. Now find a revision associated with that resource (through the ^^wiki:revisions^^ property) that contains the resource's content:
## If the URL had a revision parameter, choose the revision that matches that number
## If the URL had a label parameter, choose the last revision that has a matching label
## Choose the last revision that has a label with the ^^wiki:is-released^^ property
## Choose the last revision
# Now we retrieve the content associated with the revision (which can be either stored in external files or within the model, depending on how you configured Rhizome) and process it based on the content transform metadata associated with it (this is set by the 'Source Format' dropdown on the edit page). 
# At this point we may be ready to return the contents to the browser or we might want to apply a template to the results. To find out we look for a template resource that first matches the following queries:
## Search for a resource with a ^^wiki:handles-doctype^^ property equal to to the URL's '_doctype' parameter, if present, or the revision's ^^wiki:doctype^^ property. This allows for stylesheets that can convert content from one doctype to another.
## Search for a resource with a ^^wiki:handles-disposition^^ property equal to the URL's '_disposition' parameter, if present, or the revision's ^^wiki:item-disposition^^ property. Item disposition's correspond to the "Item type" drop-down on the Edit page and allow for template stylesheets to control how content is rendered.
:If we do find a template resource, we stuff the content of the current request into a XPath variable called '$_contents' and then, starting with the fourth step, invoke the above steps again using template resource. Note that this means that another template can be invoked on the results of this template resource and so on and so on.

; todo !!Folders

!!RSS feeds
You can create a RSS feed on nearly anything in the system by doing a search with the RSS view option. The URL for the search results can be used as the RSS URL. For example, for RSS feed of the most recently changed pages, click on the "Recent" link, change the view to RSS and then press the search button. Identical results need not be repeatedly sent as Raccoon always generates an etag for tools that support If-None-Match http headers. (Rhizome currently only supports RSS .91 but you can add easily support for later versions by editing search.xsl -- it took less than a 1/2 hour to implement .91)

!Access Control

Access control (or //authorization//) provides control over which users can access or modify particular resources and functionality. This is particularly important with Rhizome because most of its structure and behaviour is editable by users; indeed if the Python content processor is enabled (is disabled by default) the user can execute arbitrary [Python|http://python.org] code. However, in many applications you don't want to have to think about access control, so Rhizome provides an access control model that protects the core structure by default but doesn't require extra work if you're not interested in extra control.

!!Access Tokens and Permissions

The basic notion is of an //Access Token// that can be attached to (guard) any resource. Access tokens have one or more //permissions// associated with them, each of which grant the right perform a specific action. A users that has rights to a particular Access Token can perform the granted actions on all the resources that that Access Token guards. In addition, Access Tokens have a priority property, enabling more important Access Tokens to override less important ones.

One benefit with this approach is how scalable it is in terms of the complexity of your authorization scheme. If you don't care about authorization at all you just can ignore it -- it only has an effect when you attach access tokens to guard resources. But you can create complicated authorization schemes by specifying your own authorization RxPath expression by setting the ^^unAuthorizedExpr^^ config variable, enabling you to create complex path traversals (e.g. inheritance, hierarchical groups, etc.) by redefining how a resource finds the Access Token that guards it or which Access Token a user has rights to.

With Rhizome's default authorization expression, user have rights to a token either directly via the ^^auth:has-rights-to^^ property or being a member of a Role (via ^^auth:has-role^^) which in turn has rights to tokens via ^^auth:has-rights-to^^.  Similarly, resources are guarded by access tokens either directly via the ^^auth:guarded-by^^ property or indirectly by the access-tokens that guard their class resources.

!!Users and Roles

Rhizome has two preconfigured users and roles. The 'admin' user is assigned the 'super-user' role, which is a special role that has full access to the system regardless of the access tokens. The 'guest' user is a member of the 'guest' role and this is the identify the user is assumed to be until she logs in. The 'guest' user can only perform actions that don't require any access token. 

Users are assigned roles with the ^^auth:has-role^^ property -- there's currently no UI for this, so just edit the user's metadata. (With the default schema, only users with the "user-guard" access token can add or remove roles and access tokens from users.)

!!Privacy and User Groups

When a new user is created, several new access tokens are created for the user, allowing the user to set different levels of privacy for the content she edits (to learn more, take a look at [signup-handler|signup-handler?action=edit]). When you create or edit a page you'll notice a dropdown box labeled "Sharing". This drop-down contains all the access token the user has rights to (if you're not logged-in, you'll see just see the default "Public Read/Write" token because the guest user doesn't have rights to any access tokens).  When you save the page it will now require your chosen access token.

Notice that two of the "Sharing" options are labeled "Group" and "Group Write/Public Read" -- choosing these access tokens limit access to only those users who share membership in any of the User Groups you are a member of. A User group is simply a role that has the user's group access tokens to added to the role when the user joins. That way, any other user that has that user group role can access resources associated with that user's group tokens. Thus, to have a user "join" a user group, add the user to the user group role and then edit the user group role and add a ^^auth:has-rights-to^^ property for each of the user's two group access tokens. To remove her, delete those properties.

!!Fine-grained Authorization
In addition to permissions that correspond to the type of action associated with a request ("view", "edit", "save", etc.), access tokens can have permissions that exactly specify which properties can be added or removed from a given resource. The permissions ^^auth:permission-add-statement^^ and ^^auth:permission-remove-statement^^ control whether a resource can have properties added or removed. If they are modified by the presence of an ^^auth:with-property^^ property then they only apply to the properties that are the value of the ^^auth:with-property^^ property. You can further refine this with the addition of the ^^auth:with-value^^ property, which limits the access control to only those properties with that specific value. For example, the default authorization schema creates an access token to control adding an ^^item format^^ with the Python source format.

WARNING: Currently fine-grained authorization only works when editing metadata and deleting resources, but changes made by executing RxUpdate pages are not checked. Because of this, Rhizome's default schema has a specific access token for creating or modifying RxUpdate pages which must be specifically assigned to users or their roles.

In addition, Rhizome provides a simple access control scheme for modifying a request metadata via the ^^assign-metadata^^ and ^^remove-metadata^^ XPath extension functions: Any variable whose name that starts with two leading underscores ("\__") is considered read-only and can not be assigned or removed.

!Rhizome Customization

!!Simple Customization of Presentation
Here are some files useful for the basic customization of Rhizome: 
+[rhizome/basestyles.css|basestyles.css?action=edit]= Most CSS formatting rules are found here.
+[rhizome/sidebar.txt|sidebar?action=edit]= This Rhizml document is displayed as the navbar on the left hand column by the site-template.
+[rhizome/site-template.xsl|site-template?action=edit]= The XSL stylesheet that controls Rhizome's layout.

There are three ways you could modify these files:
* Just edit them in Rhizome (e.g. click on the links above)
* Place a modified copy of the file in a directory that the appears in the Racoon PATH before the 'rhizome' directory. By default, Rhizome set the PATH with the current working directory before the ^^rhizome^^ directory. (See [RacoonConfig] for more on the PATH setting). 
* Modify the files directly.

!!Slightly Involved Customization Example
In this example we'll add a template for displaying a print-friendly version of a page. (Note: going through the trouble writing and testing this example, I've decided to leave it in the core product -- see ^^print-template.xsl^^.)
#Add a new disposition
##On the [Administration] page click on the new disposition link. 
##Edit the new dispostion template: for consistency, we'll choose the resource URI of the new disposition to be "wiki:item-disposition-print" and label it 'Printable'
#Add a new template
##Click new to create a new page (let's call it 'print-template'), set the Item Format to "RxSLT" and the Item Type to "Template". (We don't want to set the format to "XSLT" because we don't want to tranform the contents that we are applying the template to (as it can be anything, not even XML); instead we just want to include the content (which is exposed as a XSLT param named $_contents) in the template's output.
##We'll base the print template stylesheet on "site-template.xsl" by removing the structural tables from template and just displaying the content: ~~
p'''<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0"
        xmlns:a="http://rx4rdf.sf.net/ns/archive#"
        xmlns:wiki="http://rx4rdf.sf.net/ns/wiki#"
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'
        xmlns:wf='http://rx4rdf.sf.net/ns/racoon/xpath-ext#'
        xmlns:f = 'http://xmlns.4suite.org/ext'
        xmlns:response-header='http://rx4rdf.sf.net/ns/racoon/http-response-header#'
        exclude-result-prefixes = "f wf a wiki rdf response-header" >		
    <xsl:param name="_contents" />		
    <xsl:param name="_previousContext" />		        
    <xsl:param name="response-header:content-type"/>    

    <xsl:output method='html' indent='no' />
    
<xsl:template match="/">

<!-- this page is always html, not the content's mimetype -->
<xsl:variable name='prev-content-type' select="$response-header:content-type" />
<xsl:variable name='content-type' select="wf:assign-metadata('response-header:content-type', 'text/html')" />

<html>
<head>
<!-- we could have a different stylesheet for printing -->
<link href="site:///basestyles.css" rel="stylesheet" type="text/css" />
</head>
<body>
         <xsl:choose>
         <xsl:when test="contains($prev-content-type,'xml')
                      or starts-with($prev-content-type,'text/html')">
            <xsl:value-of disable-output-escaping='yes' select="$_contents" />
         </xsl:when>
         <xsl:otherwise>
            <pre>
            <xsl:value-of disable-output-escaping='no' select="$_contents" />
            </pre>
         </xsl:otherwise>
        </xsl:choose>
</body>
</html>
    
</xsl:template>
</xsl:stylesheet>
'''
#Set the template to handle the new print disposition
##After saving the item, click on the "Metadata" link to get to the View Metadata page and then the "Edit Metadata" link to edit the metadata. 
##Add a ^^wiki:handles-disposition^^ property to the main (the NamedContent) resource: ~~
p''' base:print-template:    
  wiki:handles-disposition: wiki:item-disposition-print
  ...
'''
#Finally let's add "Print" link to the site template.
##Edit "site-template" 
##Find the action links in the footer of the template and add our own by copying the "view" link and adding a "_disposition" parameter to it. ~~
p'''&#xa0;<a href="site:///{$path}?_disposition=http%3A//rx4rdf.sf.net/ns/wiki%23item-disposition-print{$aboutparam}">Print</a>'''
::The _disposition parameter overrides the resources' default disposition that was set when choosing the "Item Type" on the edit page.

;!!Advanced Customization Example
;adding a todo resource type

!Importing content and schema migration

The import command adds content to the site by adding all the files that match the given path (with wildcards).

The command has these options:
p'''--import path [--recurse] [--dest path] 
        [--xupdate url] [--format format] 
        [--doctype doctype] [--disposition disposition]'''
where
~~^^path^^ Location of files to import (wildcards ok) 
~~^^-recurse^^ if present, recursively import subdirectories
~~^^-dest dir^^ If dest is present files will be copied to this directory, otherwise the site will directly reference the imported files.
~~^^-xupdate URL^^ URL to an RxUpdate file which is applied to each metarx file.
~~^^--format format^^ default format 
~~^^--disposition disposition^^ default item disposition
~~^^--doctype doctype^^ default doctype

If, for each file, there exists a matching file with ".metarx" appended, then import will attempt to add the metadata in the metarx file.  First it load the metadata file and then update it using the RxUpdate file specified by the ^^--xupdate^^ option.  If it isn't present it will run the default, "path:import.xml". This RxUpdate script disgards previous revisions and points the content to the new import location. You'll find a couple of other import scripts in the rhizome directory: one changes the base URI for the RDF resources, and another adds authorization tokens to the items. By writing your own import scripts and exporting and reimporting your site, you can migrate your site to your latest schema.

If no .metarx file exists import will use the defaults specified by the ^^--format^^, ^^--disposition^^ and ^^--doctype^^ options, if present, or attempt a guess at the metadata based on the contents and file extension of the file.

!Exporting and static websites  

You can use Rhizome's export command exports the content of each item in the site as a seperate file.  You can use it for two different types of tasks: to export raw content and metadata (for data exchange or schema migration, etc.), or to generate static versions of the website.  

The command has these options:
p'''--export dir [--static] [--xpath exp | --name name] [--label label]'''
where 
~~^^ dir^^ is the directory to export to. 
~~^^-xpath^^ RxPath expression that evaluates to a nodeset of items to export
~~^^-name^^  The name of item to export (for exporting one item) (no effect if -xpath is specified)
~~^^-label^^ Choose revisions with this label
~~^^-static^^ Export as static HTML

If the ^^-static^^ option is present, export will try to render each item as HTML. Dynamic pages (e.g. those that require query parameters) are skipped (you may see exceptions being reported to the consol). A $_static variable is introduced so stylesheets can render appropriately (for example, see site-template.xsl). Limitations: 
* External content referenced by links are not copied

If ^^-static^^ is not present each item will be exported to 2 files: one containing the raw content of item and the other a RxML document containing the metadata associated with the item. The first file will match the item's name with a file type extension added, if necessary, and the second will be the same but with '.metarx' appended.

;todo:
;!The RDF Store
